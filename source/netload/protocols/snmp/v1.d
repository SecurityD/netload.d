module netload.protocols.snmp.v1;

import std.string;
import std.conv;
import std.outbuffer;
import std.range;
import std.array;

import stdx.data.json;

import netload.core.protocol;
import netload.protocols.snmp.asn_1;
import netload.core.conversion.json_array;

/++
 + Simple Network Managment Protocol
 +/
class SNMPv1 : Protocol {
  public:
    static SNMPv1 opCall(inout JSONValue val) {
  		return new SNMPv1(val);
  	}

    this() {}

    this(JSONValue json) {
      ver = json["ver"].to!int;
      communityString = json["community_string"].get!string;
      pdu = json["pdu"].toASN1;
      if ("data" in json && json["data"] != null)
  			data = netload.protocols.conversion.protocolConversion[json["data"]["name"].get!string](json["data"]);
    }

    this(ubyte[] bytes) {
      auto seq = bytes.toASN1.data.toASN1Seq;
      ver = seq[0].data[0] + 1;
      communityString = seq[1].data.assumeUTF;
      pdu = seq[2];
    }

    override JSONValue toJson() const {
      JSONValue json = [
        "ver": JSONValue(ver),
        "community_string": JSONValue(communityString),
        "pdu": _pdu.toJSONValue,
        "name": JSONValue(name)
      ];
      return json;
    }

    unittest {
      SNMPv1 snmp = new SNMPv1;
      snmp.ver = 1;
      snmp.communityString = "public";
      snmp.pdu.type = ASN1.Type.SET_REQUEST_PDU;
      snmp.pdu.data = [
        0x02, 0x01, 0x3a, 0x02, 0x01, 0x00, 0x02, 0x01,
        0x00, 0x30, 0x6d, 0x30, 0x13, 0x06, 0x0e, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x04,
        0x30, 0x21, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04,
        0x01, 0x81, 0x7d, 0x08, 0x33, 0x08, 0x02, 0x01,
        0x03, 0x01, 0x04, 0x0f, 0x46, 0x75, 0x6a, 0x69,
        0x58, 0x65, 0x72, 0x6f, 0x78, 0x45, 0x78, 0x6f,
        0x64, 0x75, 0x73, 0x30, 0x1d, 0x06, 0x0e, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x01, 0x04, 0x01, 0x06, 0x0b, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x30, 0x14, 0x06, 0x0e, 0x2b, 0x06,
        0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33, 0x08,
        0x02, 0x01, 0x05, 0x01, 0x02, 0x02, 0x01, 0x2c
      ];

      auto json = snmp.toJson;
      assert(json["ver"].to!int == 1);
      assert(json["community_string"].get!string == "public");
      assert(json["pdu"]["type"].to!ubyte == ASN1.Type.SET_REQUEST_PDU);
      assert(json["pdu"]["data"].toArrayOf!ubyte == [
        0x02, 0x01, 0x3a, 0x02, 0x01, 0x00, 0x02, 0x01,
        0x00, 0x30, 0x6d, 0x30, 0x13, 0x06, 0x0e, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x04,
        0x30, 0x21, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04,
        0x01, 0x81, 0x7d, 0x08, 0x33, 0x08, 0x02, 0x01,
        0x03, 0x01, 0x04, 0x0f, 0x46, 0x75, 0x6a, 0x69,
        0x58, 0x65, 0x72, 0x6f, 0x78, 0x45, 0x78, 0x6f,
        0x64, 0x75, 0x73, 0x30, 0x1d, 0x06, 0x0e, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x01, 0x04, 0x01, 0x06, 0x0b, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x30, 0x14, 0x06, 0x0e, 0x2b, 0x06,
        0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33, 0x08,
        0x02, 0x01, 0x05, 0x01, 0x02, 0x02, 0x01, 0x2c
      ]);
    }

    override ubyte[] toBytes() const {
      ASN1 seq;
      seq.type = ASN1.Type.SEQUENCE;

      ASN1 ver;
      ver.type = ASN1.Type.INTEGER;
      ver.data = [ cast(ubyte)(this.ver - 1) ];
      seq.data = ver.toBytes;

      ASN1 communityString;
      communityString.type = ASN1.Type.OCTET_STRING;
      communityString.data = cast(ubyte[])(this.communityString);
      seq.data ~= communityString.toBytes;

      seq.data ~= this._pdu.toBytes;

      return seq.toBytes;
    }

    unittest {
      SNMPv1 snmp = new SNMPv1;
      snmp.ver = 1;
      snmp.communityString = "public";
      snmp.pdu.type = ASN1.Type.SET_REQUEST_PDU;
      snmp.pdu.data = [
        0x02, 0x01, 0x3a, 0x02, 0x01, 0x00, 0x02, 0x01,
        0x00, 0x30, 0x6d, 0x30, 0x13, 0x06, 0x0e, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x04,
        0x30, 0x21, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04,
        0x01, 0x81, 0x7d, 0x08, 0x33, 0x08, 0x02, 0x01,
        0x03, 0x01, 0x04, 0x0f, 0x46, 0x75, 0x6a, 0x69,
        0x58, 0x65, 0x72, 0x6f, 0x78, 0x45, 0x78, 0x6f,
        0x64, 0x75, 0x73, 0x30, 0x1d, 0x06, 0x0e, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x01, 0x04, 0x01, 0x06, 0x0b, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x30, 0x14, 0x06, 0x0e, 0x2b, 0x06,
        0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33, 0x08,
        0x02, 0x01, 0x05, 0x01, 0x02, 0x02, 0x01, 0x2c
      ];

      assert(snmp.toBytes == [
        0x30, 0x81, 0x85, 0x02, 0x01, 0x00, 0x04, 0x06,
        0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0xa3, 0x78,
        0x02, 0x01, 0x3a, 0x02, 0x01, 0x00, 0x02, 0x01,
        0x00, 0x30, 0x6d, 0x30, 0x13, 0x06, 0x0e, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x04,
        0x30, 0x21, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04,
        0x01, 0x81, 0x7d, 0x08, 0x33, 0x08, 0x02, 0x01,
        0x03, 0x01, 0x04, 0x0f, 0x46, 0x75, 0x6a, 0x69,
        0x58, 0x65, 0x72, 0x6f, 0x78, 0x45, 0x78, 0x6f,
        0x64, 0x75, 0x73, 0x30, 0x1d, 0x06, 0x0e, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x01, 0x04, 0x01, 0x06, 0x0b, 0x2b,
        0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
        0x08, 0x02, 0x30, 0x14, 0x06, 0x0e, 0x2b, 0x06,
        0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33, 0x08,
        0x02, 0x01, 0x05, 0x01, 0x02, 0x02, 0x01, 0x2c
      ]);
    }

    override string toIndentedString(uint idt = 0) const {
      OutBuffer buf = new OutBuffer();
      string indent = join(repeat("\t", idt));
      buf.writef("%s%s%s%s\n", indent, PROTOCOL_NAME, name, RESET_SEQ);
      buf.writef("%s%s%s%s : %s%s%s\n", indent, FIELD_NAME, "ver", RESET_SEQ, FIELD_VALUE, ver, RESET_SEQ);
      buf.writef("%s%s%s%s : %s%s%s\n", indent, FIELD_NAME, "community_string", RESET_SEQ, FIELD_VALUE, communityString, RESET_SEQ);
      buf.writef("%s%s%s%s : %s%s%s\n", indent, FIELD_NAME, "pdu", RESET_SEQ, FIELD_VALUE, _pdu, RESET_SEQ);
      return buf.toString;
    }

    override string toString() const {
      return toIndentedString;
    }

    @property {
      Protocol data() { return null; }
      void data(Protocol) {}

      inout string name() { return "SNMPv1"; }

      int osiLayer() const { return 7; }

	  /++
	   + The SNMP version.
	   +/
      int ver() const { return _version; }
	  ///ditto
      void ver(int data) { _version = data; }

	  /++
	   + Community, location of sender and recipient of message
	   +/
      string communityString() const { return _communityString; }
	  ///ditto
      void communityString(string data) { _communityString = data; }

	  /++
	   + PDU
	   +  - PDU Type
	   +  - Request Id, Associates Request with responses
	   +  - Error Status
	   +  - Error Index
	   +  - Variable Bindings
	   + Trap PDU
	   +  - Enterprise, type of object generating the trap
	   +  - Agent Address, address of object generating the trap
	   +  - Generic trap type
	   +  - Specific trap code
	   +  - Time stamp, time elapsed between last network reinitialization and generation of the trap
	   +  - Variable Bindings
	   +/
      ref ASN1 pdu() { return _pdu; }
	  ///ditto
      void pdu(ASN1 data) { _pdu = data; }
    }

  private:
    int _version;
    string _communityString;
    ASN1 _pdu;
}

unittest {
  ASN1 pdu;
  pdu.type = ASN1.Type.SET_REQUEST_PDU;
  pdu.data = [
    0x02, 0x01, 0x3a, 0x02, 0x01, 0x00, 0x02, 0x01,
    0x00, 0x30, 0x6d, 0x30, 0x13, 0x06, 0x0e, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x04,
    0x30, 0x21, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04,
    0x01, 0x81, 0x7d, 0x08, 0x33, 0x08, 0x02, 0x01,
    0x03, 0x01, 0x04, 0x0f, 0x46, 0x75, 0x6a, 0x69,
    0x58, 0x65, 0x72, 0x6f, 0x78, 0x45, 0x78, 0x6f,
    0x64, 0x75, 0x73, 0x30, 0x1d, 0x06, 0x0e, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x01, 0x04, 0x01, 0x06, 0x0b, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x30, 0x14, 0x06, 0x0e, 0x2b, 0x06,
    0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33, 0x08,
    0x02, 0x01, 0x05, 0x01, 0x02, 0x02, 0x01, 0x2c
  ];

  JSONValue json = [
    "ver": JSONValue(1),
    "community_string": JSONValue("public"),
    "pdu": pdu.toJSONValue
  ];

  auto snmp = cast(SNMPv1)to!SNMPv1(json);
  assert(snmp.ver == 1);
  assert(snmp.communityString == "public");
  assert(snmp.pdu.type == ASN1.Type.SET_REQUEST_PDU);
  assert(snmp.pdu.length == 120);
  assert(snmp.pdu.data == [
    0x02, 0x01, 0x3a, 0x02, 0x01, 0x00, 0x02, 0x01,
    0x00, 0x30, 0x6d, 0x30, 0x13, 0x06, 0x0e, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x04,
    0x30, 0x21, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04,
    0x01, 0x81, 0x7d, 0x08, 0x33, 0x08, 0x02, 0x01,
    0x03, 0x01, 0x04, 0x0f, 0x46, 0x75, 0x6a, 0x69,
    0x58, 0x65, 0x72, 0x6f, 0x78, 0x45, 0x78, 0x6f,
    0x64, 0x75, 0x73, 0x30, 0x1d, 0x06, 0x0e, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x01, 0x04, 0x01, 0x06, 0x0b, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x30, 0x14, 0x06, 0x0e, 0x2b, 0x06,
    0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33, 0x08,
    0x02, 0x01, 0x05, 0x01, 0x02, 0x02, 0x01, 0x2c
  ]);
}

unittest {
  ubyte[] raw = [
    0x30, 0x81, 0x85, 0x02, 0x01, 0x00, 0x04, 0x06,
    0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0xa3, 0x78,
    0x02, 0x01, 0x3a, 0x02, 0x01, 0x00, 0x02, 0x01,
    0x00, 0x30, 0x6d, 0x30, 0x13, 0x06, 0x0e, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x04,
    0x30, 0x21, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04,
    0x01, 0x81, 0x7d, 0x08, 0x33, 0x08, 0x02, 0x01,
    0x03, 0x01, 0x04, 0x0f, 0x46, 0x75, 0x6a, 0x69,
    0x58, 0x65, 0x72, 0x6f, 0x78, 0x45, 0x78, 0x6f,
    0x64, 0x75, 0x73, 0x30, 0x1d, 0x06, 0x0e, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x01, 0x04, 0x01, 0x06, 0x0b, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x30, 0x14, 0x06, 0x0e, 0x2b, 0x06,
    0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33, 0x08,
    0x02, 0x01, 0x05, 0x01, 0x02, 0x02, 0x01, 0x2c
  ];
  auto snmp = cast(SNMPv1)raw.to!SNMPv1;
  assert(snmp.ver == 1);
  assert(snmp.communityString == "public");
  assert(snmp.pdu.type == ASN1.Type.SET_REQUEST_PDU);
  assert(snmp.pdu.length == 120);
  assert(snmp.pdu.data == [
    0x02, 0x01, 0x3a, 0x02, 0x01, 0x00, 0x02, 0x01,
    0x00, 0x30, 0x6d, 0x30, 0x13, 0x06, 0x0e, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x04,
    0x30, 0x21, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04,
    0x01, 0x81, 0x7d, 0x08, 0x33, 0x08, 0x02, 0x01,
    0x03, 0x01, 0x04, 0x0f, 0x46, 0x75, 0x6a, 0x69,
    0x58, 0x65, 0x72, 0x6f, 0x78, 0x45, 0x78, 0x6f,
    0x64, 0x75, 0x73, 0x30, 0x1d, 0x06, 0x0e, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x01, 0x04, 0x01, 0x06, 0x0b, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33,
    0x08, 0x02, 0x30, 0x14, 0x06, 0x0e, 0x2b, 0x06,
    0x01, 0x04, 0x01, 0x81, 0x7d, 0x08, 0x33, 0x08,
    0x02, 0x01, 0x05, 0x01, 0x02, 0x02, 0x01, 0x2c
  ]);
}
